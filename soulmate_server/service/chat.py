import randomimport timeimport tracebackimport uuidfrom soulmate_server.common.mysql_tool import mysqlSession, Sessionfrom soulmate_server.conf.chatConf import chatModelConf, tokenRate, get_random_chat_messagefrom soulmate_server.conf.forbiddenWordsConf import forbiddenWords, get_random_forbidden_messagefrom soulmate_server.conf.systemConf import fileSrc, file_pathfrom soulmate_server.conf.taskConf import charSetting, getSystemSettingfrom soulmate_server.mapper.chat import addChatMessage, getTodayMessage, \    getChatMessageForConclusion, updateChatMessageForConclusion, getChatMessageByTokenfrom soulmate_server.mapper.message import addMessageByTypefrom soulmate_server.mapper.role import addUserRole, selectRoleDetails, selectUserByRoleMemory, \    selectUserByRoleMemoryLimit3from soulmate_server.mapper.user import selectUserRoleAchievement, addAchievementDetails, addIntimacy, \    addIntimacyDetails, selectTodayIntimacyDetails, queryUserInfoById, updateUserCard, reduceUserEnergy, queryUserRole, \    queryUserRoleByFilter, reduceUserEnergyBy0from soulmate_server.models import createDynamicTablefrom soulmate_server.models.dynamic import redisMessagefrom soulmate_server.models.role import RoleMemoryfrom soulmate_server.models.user import UserRole, AchievementDetails, UserRoleAchievement, IntimacyLog, \    DailyTaskDetails, IntimacyEventfrom soulmate_server.common.redis_tool import *from soulmate_server.utils.chat import *import datetimeimport asynciofrom soulmate_server.models.other import SummaryLog, Message, MessageObject, GPTLogfrom soulmate_server.utils.mp3 import mp3_to_text, txtToWav, get_audio_duration, elevenlabs_to_wavfrom soulmate_server.utils.mqtt import mqttCofrom soulmate_server.utils.scheduler import SchedulerManagerfrom soulmate_server.utils.textUtil import find_prohibited_wordsfrom soulmate_server.utils.tool import isNotEmptyfrom soulmate_server.utils.vector import insertData, searchData# 聊天def chatService(userId: str, roleId: str, role: str, message_type: int, lockId: str = None, voiceUrl: str = None,                srcVoiceUrl: str = None,                message: str = None, sql: mysqlSession = None):    # 设置锁 同步定时与前端调用保持一致    # 锁id    chatRecord = None    # 创建动态表,返回动态类    UserChatClass = createDynamicTable(userId, tablePrefix='chat')    if lockId is None:        print("lockId为null")        lockId = uuid.uuid4().hex    try:        userInfo = queryUserInfoById(sql=sql, userId=userId)        if userInfo is None:            print("用户信息没有返回")            return False        timestamp = int(datetime.datetime.now().timestamp() * 1000)        # 实现逻辑 搭配全接口使用        redisMessages = None        if message_type == 0:            tokenSize = num_tokens_from_messages([{"role": "user", "content": message}])            chatRecord = UserChatClass(chatId=uuid.uuid4().hex, roleId=roleId, content=message, role=role,                                       createTime=timestamp, readStatus=1,                                       updateTime=timestamp, inputType=0,                                       tokenSize=tokenSize)            if userInfo.energy * tokenRate <= 0:                print("能力没有返回")                return False            redisMessages = redisMessage(message, message_type, tokenSize)        if message_type == 1:            message = to_txt(srcVoiceUrl)            tokenSize = num_tokens_from_messages([{"role": "user", "content": message}])            if tokenSize > userInfo.energy * tokenRate:                print("能力没有返回")                return False            chatRecord = UserChatClass(chatId=uuid.uuid4().hex, roleId=roleId, content=message,                                       role=role,                                       createTime=timestamp, readStatus=1,                                       updateTime=timestamp, inputType=1, voiceUrl=voiceUrl,                                       voiceSize=get_audio_duration(srcVoiceUrl),                                       tokenSize=tokenSize)            redisMessages = redisMessage(chatRecord.content, message_type, tokenSize)        addChatMessage(sql, chatRecord)        userRole = UserRole(userId=userId, roleId=roleId, createTime=timestamp, userRoleId=uuid.uuid4())        addUserRole(sql, userRole)        # 保存到redis        # 声明一个消息list        key = "message:" + userId + roleId        if existsKey(key):            json_str = json.dumps(redisMessages.__dict__)            redis_lpush(key, json_str)        else:            messageList = []            json_str = json.dumps(redisMessages.__dict__)            messageList.append(json_str)            redis_setList(key, messageList, expireTime=600)        sql.commit()        # 锁状态 0初始化，1锁定，2释放        print(lockId)        if lockId is None or existsKey('LOCK:' + userId + roleId) == 0:            setExKey('LOCK:' + userId + roleId, 600, 0)            print("进入定时")            # 设置任务和触发器，4秒后执行            SchedulerManager().add_single_run_job(func=chatTask, delay_seconds=4, args=[userId, roleId, lockId])    except Exception as e:        sql.rollback()        print(e)    return {"lockId": lockId,            "message": sql.query(UserChatClass).filter(UserChatClass.chatId == chatRecord.chatId).first()}def chatTask(userId, roleId, lockId):    key = "LOCK:" + userId + str(roleId)    # 在一分钟内每秒都查看状态并进行处理    for _ in range(60):        # 判断锁状态        lockStatus = redis_get('LOCK:' + userId + roleId)        if lockStatus is None:            print("执行定时恢复锁状态没有")        print("执行定时恢复锁状态" + str(lockStatus))        if lockStatus is not None and lockStatus == '0':            # 这个锁还未锁定 表示4秒后未收到回调 那么我就直接做处理            if existsKey(key) == 1:                sql = mysqlSession                start_background_task(userId=userId, roleId=roleId, sql=sql, lockId=lockId, taskType=1)                sql.commit()                sql.expire_all()                break            # 预留一分钟每秒查询redis 查看状态 后续可补死锁 或者锁释放查询是否执行成功需不需要重新执行做扩展            time.sleep(1)def start_background_task(userId: str, roleId: str, lockId: str, taskType: int, sql: mysqlSession = None):    # 在后台线程中运行异步函数    chatRollBackSendGpt(userId=userId, roleId=roleId, lockId=lockId, taskType=taskType, sql=sql)def chatRollBackSendGpt(userId, roleId, lockId, sql: mysqlSession = mysqlSession, taskType: int = 0):    try:        print(str(taskType) + "调用类型")        # 进入回调先上锁 避免多次调用 此锁非同步锁 而是每个线程一个锁        redis_set('LOCK:' + userId + roleId, 1)        # 从redis获取消息        key = "message:" + userId + str(roleId)        messageList = redis_getList(key)        if messageList is None or len(messageList) == 0:            return        messages = []        # 查询用户信息        userInfo = queryUserInfoById(userId=userId, sql=sql)        timestamp = int(datetime.datetime.now().timestamp() * 1000)        # 添加回复消息        UserChatClass = createDynamicTable(userId, tablePrefix='chat')        for json_str in messageList:            json_data = json.loads(json_str)            re = find_prohibited_words(json_data['message'], forbiddenWords)            if re:                chatGpt = UserChatClass(chatId=uuid.uuid4().hex, roleId=roleId, content=get_random_forbidden_message(),                                        role="assistant",                                        createTime=timestamp,                                        readStatus=0 if taskType == 1 else 1,                                        inputType=0                                        )                saveAndPush(sql=sql, userId=userId, chatGpt=chatGpt)                redis_delete(key)                sql.commit()                return            message = redisMessage(message=json_data['message'], message_type=json_data['message_type'],                                   token=json_data['token'])            messages.append(message)        roleInfo = selectRoleDetails(roleId, userId, sql=sql)        roleSetting = roleInfo.get("setting")        print(userInfo)        userSetting = userInfo.setting        memories = "####" + roleInfo.get("name") + "'s Memories"        # 查询角色事件 朋友圈 近三条        roleMemory = selectUserByRoleMemoryLimit3(userId, roleId, sql=sql)        if roleMemory is not None:            for item in roleMemory:                memories = memories + '\n' + convert_milliseconds_to_datetime(item.publishTime) + ":" + item.content        # 拼接摘要        memories = "\n###Memories\n" + memories + "\n"        # 获取当前时间        current_time = datetime.datetime.now()        # 将当前时间格式化成字符串        formatted_time = current_time.strftime("%B %d, %Y, %H:%M:%S")        # 获取系统设置前缀规则        system = getSystemSetting(formatted_time)        systemSetting = "<Command>\n" + system + roleSetting + '\n' + userSetting + '\n' + memories + charSetting + "\n</Command>"        # 摘要        # vusData = searchData(messages, userId + "_" + roleId + "_conclusion")        # if vusData is not None:        #     for item in vusData:        #         systemSetting = systemSetting + '\n' + item.get('content')        sendMessage = []        send = []        return_messageType = 0        MessageContext = ""        tokenNum = 0        for item in getChatMessageByToken(userId, roleId, 1000, sql):            MessageContext = MessageContext + '\n' + "role:" + item.get('role') + ',' + "content:" + item.get('content')            tokenNum = tokenNum + item.get('tokenSize')        redisMessageString = ''        for index, item in enumerate(messages):            if index == len(messages) - 1:                return_messageType = item.message_type            tokenNum = tokenNum + item.token            redisMessageString = redisMessageString + ',' + "role:" + "user" + ',' + "content:" + item.message            # MessageContext = MessageContext + '\n' + "role:user,content:" + item.message        if redisMessageString != '':            send.append({"role": "user", "content": redisMessageString})        MessageContext = "<Context>" + MessageContext + "\n</Context>"        # 系统设置        sendMessage.append(            {"role": "system", "content": systemSetting + MessageContext}        )        for it in send:            sendMessage.append(it)        userToken = userInfo.energy * tokenRate        if (userToken < tokenNum):            print("用户token不足 重置0")            reduceUserEnergyBy0(userId, sql=sql)        # 记录开始时间        start_time = time.time()        # 发送gpt        result = chatgpt(sendMessage, model=userInfo.model)        # 记录结束时间        end_time = time.time()        # 计算耗时        elapsed_time = end_time - start_time        print(f"代码块执行时间：{elapsed_time} 秒")        print(result)        sql.add(GPTLog(gptLogId=uuid.uuid4().hex,                       content=str(result),                       model="4" if userInfo.model == 2 else "3",                       promptTokens=result.get('response').get('usage').get('prompt_tokens') if result.get(                           'status') == True else "There's been a mistake",                       completionTokens=result.get('response').get('usage').get('completion_tokens') if result.get(                           'status') == True else "There's been a mistake",                       totalTokens=result.get('response').get('usage').get('total_tokens') if result.get(                           'status') == True else "There's been a mistake",                       type=0,                       createTime=int(datetime.datetime.now().timestamp() * 1000),                       ))        GptTxt = result.get('response').choices[            0].message.content if result.get(            'status') == True else "There's been a mistake"        gptResult = process_string(GptTxt)        if result.get(                'status') == True:            jsonResult = json.loads(gptResult)            level = jsonResult.get("Disclosure")            if level is not None:                if isinstance(level, str):                    level = del_percent(level)                if int(level) > 80:                    GptTxt = get_random_chat_message()                else:                    GptTxt = jsonResult.get("Content")            else:                GptTxt = gptResult        # 扣体力校验体力        print(GptTxt)        chatGpt = None        if return_messageType == 0:            chatGpt = UserChatClass(chatId=uuid.uuid4().hex, roleId=roleId, content=GptTxt, role="assistant",                                    createTime=timestamp,                                    readStatus=0 if taskType == 1 else 1,                                    inputType=0,                                    tokenSize=result.get('response').get('usage').get('prompt_tokens') if result.get(                                        'status') == True else "There's been a mistake"                                    )        if return_messageType == 1:            fileName = uuid.uuid4().hex            elevenlabs_to_wav(roleInfo.get('voice'), fileName, GptTxt)            chatGpt = UserChatClass(chatId=uuid.uuid4().hex, roleId=roleId, content=GptTxt, role="assistant",                                    createTime=timestamp, inputType=1,                                    readStatus=0 if taskType == 1 else 1,                                    voiceUrl=fileSrc + 'wav/' + fileName + '.wav',                                    voiceSize=get_audio_duration(file_path + '/wav/' + fileName + '.wav'),                                    tokenSize=result.get('response').get('usage').get('prompt_tokens') if result.get(                                        'status') == True else "There's been a mistake"                                    )        addChatMessage(sql, chatGpt)        sendMess = {"chatId": chatGpt.chatId,                    "roleId": chatGpt.roleId,                    "content": chatGpt.content,                    "role": chatGpt.role,                    "createTime": chatGpt.createTime,                    "readStatus": chatGpt.readStatus,                    "inputType": chatGpt.inputType,                    "voiceUrl": chatGpt.voiceUrl,                    "voiceSize": chatGpt.voiceSize,                    "tokenSize": chatGpt.tokenSize}        if sendMess.get("content") is not None:            sendMess.update({"content": sendMess.get("content").replace('"', "'")})        # 发送消息        mq = mqttCo        me = MessageObject(clear=False, content=json.dumps(sendMess), messageType=2)        me_dict = me.to_dict()        js = json.dumps(me_dict)        mq.publish(topic=userId, message=str(js))        print("本次消耗token" + str(result.get('response').get('usage').get('total_tokens') if result.get(            'status') == True else "There's been a mistake"))        reduceEnergy = None        if result.get('status') == True:            print("本次消耗token" + str(result.get('response').get('usage').get('total_tokens')))            reduceEnergy = float(result.get('response').get('usage').get('total_tokens')) / tokenRate            print("本次对话消耗能量" + str(reduceEnergy))            # 修改用户体力            reduceUserEnergy(userId,                             userInfo.energy - reduceEnergy,                             sql=sql)        # 修改用户体力        redis_delete(key)        # 执行完释放锁        # redis_set('LOCK:' + userId + roleId , 2)        redis_delete('LOCK:' + userId + roleId)        # 记录开始时间        start_time = time.time()        # 设置任务和触发器，4秒后执行        # 设置本次总结与计算亲密度唯一标识        conclusionId = uuid.uuid4().hex        if result.get(                'status') == True:            SchedulerManager().add_single_run_job(func=intimacyService, delay_seconds=2,                                                  args=[userId, roleId, conclusionId])            SchedulerManager().add_single_run_job(func=asyncToken, delay_seconds=3,                                                  args=[result.get('response').get('usage').get('total_tokens'), roleId,                                                        userId,                                                        chatModelConf.get(str(userInfo.model)).get('maxToken'),                                                        conclusionId])        # intimacyService(userId, roleId, sql=sql)        #        # asyncToken(result.get('response').get('usage').get('total_tokens'), roleId, userId,        #            chatModelConf.get(str(userInfo.model)).get('maxToken'), sql=sql)        end1_time = time.time()        # 计算耗时        elapsed1_time = end1_time - start_time        print(elapsed1_time)        sql.commit()    except Exception as e:        traceback.print_exc()        sql.rollback()        print(e)def convert_milliseconds_to_datetime(milliseconds):    # 将毫秒时间戳转换为秒    seconds = milliseconds / 1000.0    # 创建一个表示日期和时间的datetime对象    dt_object = datetime.datetime.fromtimestamp(seconds)    # 将datetime对象格式化为指定的字符串格式    formatted_date_time = dt_object.strftime('%Y/%m/%d %H:%M')    return formatted_date_timedef saveAndPush(sql: mysqlSession, userId, chatGpt):    addChatMessage(sql, chatGpt)    sendMess = {"chatId": chatGpt.chatId,                "roleId": chatGpt.roleId,                "content": chatGpt.content,                "role": chatGpt.role,                "createTime": chatGpt.createTime,                "readStatus": chatGpt.readStatus,                "inputType": chatGpt.inputType,                "voiceUrl": chatGpt.voiceUrl,                "voiceSize": chatGpt.voiceSize,                "tokenSize": chatGpt.tokenSize}    # 发送消息    mq = mqttCo    me = MessageObject(clear=False, content=json.dumps(sendMess), messageType=2)    me_dict = me.to_dict()    js = json.dumps(me_dict)    mq.publish(topic=userId, message=str(js))# 每发一次消息要结算一次亲密度def intimacyService(userId: str, roleId: str, conclusionId: str):    sql = Session()    try:        # 查询成就        ac = selectUserRoleAchievement(userId, roleId, sql=sql)        # 查询当天的聊天条数        todayMessage = getTodayMessage(userId, roleId, sql=sql)        # 走成就逻辑        AchievementService(ac, todayMessage, userId, roleId, sql=sql)        # 走日常任务逻辑        DailyTaskService(todayMessage, userId, roleId, sql=sql)        # 查询当前用户与角色的亲密度如果超过了100那么就随机1-5给他加能量并使用mqtt给前端推送        intimacy = selectRoleDetails(roleId, userId, sql)        if intimacy is not None and intimacy.get("intimacy") is not None:            if int(intimacy.get("intimacy")) >= 100:                num = random.randint(1, 5)                # 随机1-5                addIntimacy(userId, roleId, num, sql=sql)                addIntimacyDetails(IntimacyLog(                    intimacyLogId=uuid.uuid4().hex,                    userId=userId,                    roleId=roleId,                    intimacy=10,                    type=0,                    triggerType=2,                    createTime=int(datetime.datetime.now().timestamp() * 1000),                    triggerDetails=IntimacyEvent.AMOUNT100MESSAGE                ), sql=sql)                # 新增日常消息 添加体力                addMessageByType(userId=userId, messageType=IntimacyEvent.AMOUNT100MESSAGE, roleId=roleId, sql=sql)            # 使用mqtt推送给前端    except Exception as e:        print(e)        sql.rollback()    sql.commit()    sql.expire_all()# 关于成就的逻辑 还是老样子查库里是否有过这个成就 没有就添加并增加亲密度 有则不做处理def AchievementService(ac, todayMessage, userId, roleId, sql: mysqlSession = None):    if todayMessage > 0:        # 检查是否存在 AchievementDetails 等于 初次聊天成就 的记录        exists_record_with_achievement = any(            record.AchievementDetails == AchievementDetails.FIRST.value for record in ac)        if not exists_record_with_achievement:            userRole = sql.query(UserRole).filter(UserRole.userId == userId, UserRole.roleId == roleId,                                                  UserRole.status == 0,                                                  UserRole.intimacy < 100).first()            if userRole is not None:                # 不存在,添加一条 AchievementDetails 等于 初次聊天成就 的记录                userRoleAchievement = UserRoleAchievement(                    userRoleAchievementId=uuid.uuid4().hex,                    userId=userId,                    roleId=roleId,                    status=0,                    accomplishment="初次聊天",                    accomplishmentType=0,                    AchievementDetails=AchievementDetails.FIRST.value,                    createTime=int(datetime.datetime.now().timestamp() * 1000)                )                addAchievementDetails(userRoleAchievement, sql=sql)                addIntimacy(userId, roleId, 5, sql=sql)                addIntimacyDetails(IntimacyLog(                    intimacyLogId=uuid.uuid4().hex,                    userId=userId,                    roleId=roleId,                    intimacy=5,                    type=0,                    triggerType=1,                    createTime=int(datetime.datetime.now().timestamp() * 1000),                    triggerDetails=AchievementDetails.FIRST.value                ), sql=sql)                addMessageByType(userId=userId, roleId=roleId, messageType=AchievementDetails.FIRST.value, sql=sql)        if todayMessage >= 10:            userRole = sql.query(UserRole).filter(UserRole.userId == userId, UserRole.roleId == roleId,                                                  UserRole.status == 0,                                                  UserRole.intimacy < 100).first()            if userRole is not None:                # 检查是否存在 AchievementDetails 等于 聊天达到十句成就 的记录                exists_record_with_achievement = any(                    record.AchievementDetails == AchievementDetails.COUNT10.value for record in ac)                if not exists_record_with_achievement:                    # 不存在,添加一条 AchievementDetails 等于 聊天达到十句成就 的记录                    userRoleAchievement = UserRoleAchievement(                        userRoleAchievementId=uuid.uuid4().hex,                        userId=userId,                        roleId=roleId,                        status=0,                        accomplishment="聊天达到十句",                        accomplishmentType=0,                        AchievementDetails=AchievementDetails.COUNT10.value,                        createTime=int(datetime.datetime.now().timestamp() * 1000)                    )                    addAchievementDetails(userRoleAchievement, sql=sql)                    addIntimacy(userId, roleId, 10, sql=sql)                    addIntimacyDetails(IntimacyLog(                        intimacyLogId=uuid.uuid4().hex,                        userId=userId,                        roleId=roleId,                        intimacy=10,                        type=0,                        triggerType=1,                        createTime=int(datetime.datetime.now().timestamp() * 1000),                        triggerDetails=AchievementDetails.COUNT10.value                    ), sql=sql)                    addMessageByType(userId=userId, roleId=roleId, messageType=AchievementDetails.COUNT10.value,                                     sql=sql)        if todayMessage >= 100:            # 检查是否存在 AchievementDetails 等于 聊天达到一百句成就 的记录            exists_record_with_achievement = any(                record.AchievementDetails == AchievementDetails.COUNT100.value for record in ac)            if not exists_record_with_achievement:                userRole = sql.query(UserRole).filter(UserRole.userId == userId, UserRole.roleId == roleId,                                                      UserRole.status == 0,                                                      UserRole.intimacy < 100).first()                if userRole is not None:                    # 不存在,添加一条 AchievementDetails 等于 聊天达到一百句成就 的记录                    userRoleAchievement = UserRoleAchievement(                        userRoleAchievementId=uuid.uuid4().hex,                        userId=userId,                        roleId=roleId,                        status=0,                        accomplishment="聊天达到一百句",                        accomplishmentType=0,                        AchievementDetails=AchievementDetails.COUNT100.value,                        createTime=int(datetime.datetime.now().timestamp() * 1000)                    )                    addAchievementDetails(userRoleAchievement, sql=sql)                    addIntimacy(userId, roleId, 10, sql=sql)                    addIntimacyDetails(IntimacyLog(                        intimacyLogId=uuid.uuid4().hex,                        userId=userId,                        roleId=roleId,                        intimacy=10,                        type=0,                        triggerType=1,                        createTime=int(datetime.datetime.now().timestamp() * 1000),                        triggerDetails=AchievementDetails.COUNT100.value                    ), sql=sql)                    addMessageByType(userId=userId, roleId=roleId, messageType=AchievementDetails.COUNT100.value,                                     sql=sql)    return Truedef DailyTaskService(todayMessage, userId, roleId, sql: mysqlSession = None):    if todayMessage > 0:        logs = selectTodayIntimacyDetails(userId, roleId)        # 检查是否存在 AchievementDetails 等于 每日聊一次就加1 的记录        exists_record_with_DailyTaskDetails = any(            record.triggerDetails == DailyTaskDetails.TODAY.value for record in logs)        if not exists_record_with_DailyTaskDetails:            userRole = sql.query(UserRole).filter(UserRole.userId == userId, UserRole.roleId == roleId,                                                  UserRole.status == 0,                                                  UserRole.intimacy < 100).first()            if userRole is not None:                # 不存在,添加一条 AchievementDetails 等于 每日聊一次就加1 的记录                addIntimacy(userId, roleId, 1, sql=sql)                addIntimacyDetails(IntimacyLog(                    intimacyLogId=uuid.uuid4().hex,                    userId=userId,                    roleId=roleId,                    intimacy=1,                    type=0,                    triggerType=0,                    createTime=int(datetime.datetime.now().timestamp() * 1000),                    triggerDetails=DailyTaskDetails.TODAY.value                ), sql=sql)                addMessageByType(userId=userId, roleId=roleId, messageType=DailyTaskDetails.TODAY.value, sql=sql)        if todayMessage >= 10:            # 检查是否存在 AchievementDetails 等于 每日到达10句就+2 的记录            exists_record_with_DailyTaskDetails = any(                record.triggerDetails == DailyTaskDetails.TODAYCOUNT10.value for record in logs)            if not exists_record_with_DailyTaskDetails:                # 不存在,添加一条 AchievementDetails 等于 每日到达10句就+2 的记录                userRole = sql.query(UserRole).filter(UserRole.userId == userId, UserRole.roleId == roleId,                                                      UserRole.status == 0,                                                      UserRole.intimacy < 100).first()                if userRole is not None:                    addIntimacy(userId, roleId, 2, sql=sql)                    addIntimacyDetails(IntimacyLog(                        intimacyLogId=uuid.uuid4().hex,                        userId=userId,                        roleId=roleId,                        intimacy=2,                        type=0,                        triggerType=0,                        createTime=int(datetime.datetime.now().timestamp() * 1000),                        triggerDetails=DailyTaskDetails.TODAYCOUNT10.value                    ), sql=sql)                    addMessageByType(userId=userId, roleId=roleId, messageType=DailyTaskDetails.TODAYCOUNT10.value,                                     sql=sql)    return True# 异步执行获取全部token总数def asyncToken(token, roleId, userId, maxToken, conclusionId):    sql = Session()    try:        print('进入异步执行获取全部token数')        # 获取redis中token数的key        redisKey = "tokenSum:" + userId + '_' + str(roleId)        # 查询是否此key是否存在 不存在就新增 存在 判断是否到达上限 若否就相加 若是则异步执行总结方法        if existsKey(redisKey) == 0:            redis_set(redisKey, token)        else:            redisToken = redis_get(redisKey)            totalToken = int(redisToken)            if totalToken + int(token) >= maxToken:                asyncConclusion(roleId, userId, 100, sql=sql)            else:                redis_set(redisKey, totalToken + int(token))    except Exception as e:        print(e)        sql.rollback()# 异步执行执行总结def asyncConclusion(roleId, userId, maxToken, sql: mysqlSession = None):    gptLogId = ""    try:        print('进入异步执行执行总结')        # 查询所有为总结的历史记录        messageList = getChatMessageForConclusion(userId, roleId)        # 循环得出token        forToken = 0        # 初始化需要修改总结标识的消息list        updateMessageList = []        userInfo = queryUserInfoById(userId, sql)        # 查询角色信息        roleInfo = selectRoleDetails(roleId, userId, sql)        roleCard = roleInfo.get(            'setting')        rule = chatPrompt        userCard = '##userCard：' + '\n' + '\n' + userInfo.setting        chatHistory = 'dialogue：'        # for循环查出来的历史记录 实现流程 循环时将token相加 每次循环的最后进行判断token是否达到上限 若到达上限便进行总结逻辑后        for it in messageList:            if it.tokenSize is not None:                forToken = forToken + it.tokenSize                if isNotEmpty(it.content):                    chatHistory = chatHistory + '\n' + it.role + ':' + it.content                    # 给需要修改的消息list赋值 由于修改需要id 而需要总结的list传入gpt时格式固定 不能有多余的属性 便创建修改list                    updateMessageList.append(it.chatId)            # token到达上限进行逻辑            if forToken >= maxToken:                # 给gpt发送总结用户视角的摘要                MessageChatResult = chatgpt(                    [{'role': 'system', 'content': userCard + '\n' + roleCard + '\n' + chatHistory + '\n' + rule}],                    model=1)                gptLogId = uuid.uuid4().hex                sql.add(GPTLog(gptLogId=gptLogId,                               content=str(MessageChatResult),                               model="4",                               promptTokens=MessageChatResult.get('response').get('usage').get('prompt_tokens'),                               completionTokens=MessageChatResult.get('response').get('usage').get('completion_tokens'),                               totalTokens=MessageChatResult.get('response').get('usage').get('total_tokens'),                               type=2,                               createTime=int(datetime.datetime.now().timestamp() * 1000),                               ))                gptResult = MessageChatResult.get('response').choices[0].message.content                gptResult = process_string(gptResult)                jsonResult = json.loads(gptResult)                Conclusion_message = {"content": jsonResult.get("SummaryContent"),                                      "role": "assistant"}                if jsonResult.get("SummaryContent") is not None:                    if isinstance(jsonResult.get("SummaryContent"), dict):                        Conclusion_message.update({"content": jsonResult.get("SummaryContent").get("SummaryContent")})                if Conclusion_message.get("content") is not None and Conclusion_message.get("content") != "":                    # 添加到向量数据库中                    insertData([jsonResult.get("SummaryContent")],                               [num_tokens_from_messages([Conclusion_message], userInfo.model)],                               "summary_" + userId + "_" + roleId + "_conclusion")                if jsonResult.get("UserCard") is not None and isinstance(jsonResult.get('UserCard'), dict):                    # 给GPT发送更新用户卡                    updateUserCard(userId, updateUser(userInfo.setting, jsonResult.get('UserCard')),                                   sql=sql)                # 重置需要总结的消息历史 接着循环                chatHistory = 'dialogue：'                # 重置循环相加的总token值                forToken = 0                # 修改需要总结的消息历史                updateChatMessageForConclusion(userId, updateMessageList, sql=sql)                sql.add(SummaryLog(                    summaryId=uuid.uuid4().hex,                    userId=userId,                    roleId=roleId,                    content='总结成功',                    gptLogId=gptLogId,                    createTime=int(datetime.datetime.now().timestamp() * 1000),                ))                updateMessageList.clear()        # 重置覆盖redis中的token        redis_set("tokenSum:" + userId + '_' + str(roleId), '0')        sql.commit()        sql.expire_all()    except Exception as e:        print("总结失败了 失败原因" + str(e))        sql.add(SummaryLog(            summaryId=uuid.uuid4().hex,            userId=userId,            roleId=roleId,            gptLogId=gptLogId,            content='总结失败' + str(e),            createTime=int(datetime.datetime.now().timestamp() * 1000),        ))        sql.commit()        sql.expire_all()        # 打印错误信息        # traceback.print_exc()    # 逻辑处理完断开数据库连接    # 待定# 同步数据def syncData(roleAndChat: dict, userId: str, sql: mysqlSession = None):    allMessageRoles = queryUserRoleByFilter(roleIds=roleAndChat.keys(), userId=userId, sql=sql)    # 创建动态表,返回动态类    UserChatClass = createDynamicTable(userId, tablePrefix='chat')    data = {}    for key, value in roleAndChat.items():        subquery = (            sql.query(UserChatClass.createTime)            .filter(UserChatClass.chatId == value, UserChatClass.status == 0)            .order_by(UserChatClass.createTime.asc())            .limit(1)            .scalar_subquery()        )        main_query = (            sql.query(UserChatClass)            .filter(UserChatClass.createTime > subquery, UserChatClass.status == 0)            .filter(UserChatClass.roleId == key)            .limit(1000)        )        data.update({key: main_query.all()})    if allMessageRoles is not None and len(allMessageRoles) > 0:        for item in allMessageRoles:            query = (                sql.query(UserChatClass)                .filter(UserChatClass.roleId == item, UserChatClass.status == 0)                .limit(1000)            )            data.update({item: query.all()})    return datadef updateAllMessageReadStatus(userId: str, roleId: str, sql: mysqlSession = None):    try:        with sql.no_autoflush:            UserChatClass = createDynamicTable(userId, tablePrefix='chat')            sql.query(UserChatClass).filter(UserChatClass.roleId == roleId).update({UserChatClass.readStatus: 1})        # 在这里可以手动提交        sql.commit()    except Exception as e:        # 处理异常，例如打印日志或回滚事务        print(f"Error: {e}")        sql.rollback()    finally:        # 最后关闭会话        sql.close()    return True